// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;
	using static GLib.AbiStructExtension;

#region Autogenerated code
	public partial class GestureDrag : Gtk.GestureSingle {

		public GestureDrag (IntPtr raw) : base(raw) {}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr d_gtk_gesture_drag_new(IntPtr widget);
		static d_gtk_gesture_drag_new gtk_gesture_drag_new = FuncLoader.LoadFunction<d_gtk_gesture_drag_new>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gtk), "gtk_gesture_drag_new"));

		public GestureDrag (Gtk.Widget widget) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (GestureDrag)) {
				var vals = new List<GLib.Value> ();
				var names = new List<string> ();
				if (widget != null) {
					names.Add ("widget");
					vals.Add (new GLib.Value (widget));
				}
				CreateNativeObject (names.ToArray (), vals.ToArray ());
				return;
			}
			owned = true;
			Raw = gtk_gesture_drag_new(widget == null ? IntPtr.Zero : widget.Handle);
		}

		[GLib.Signal("drag-end")]
		public event Gtk.DragEndHandler DragEnd {
			add {
				this.AddSignalHandler ("drag-end", value, typeof (Gtk.DragEndArgs));
			}
			remove {
				this.RemoveSignalHandler ("drag-end", value);
			}
		}

		[GLib.Signal("drag-begin")]
		public event Gtk.DragBeginHandler DragBegin {
			add {
				this.AddSignalHandler ("drag-begin", value, typeof (Gtk.DragBeginArgs));
			}
			remove {
				this.RemoveSignalHandler ("drag-begin", value);
			}
		}

		[GLib.Signal("drag-update")]
		public event Gtk.DragUpdateHandler DragUpdate {
			add {
				this.AddSignalHandler ("drag-update", value, typeof (Gtk.DragUpdateArgs));
			}
			remove {
				this.RemoveSignalHandler ("drag-update", value);
			}
		}

		static DragBeginNativeDelegate DragBegin_cb_delegate;
		static DragBeginNativeDelegate DragBeginVMCallback {
			get {
				if (DragBegin_cb_delegate == null)
					DragBegin_cb_delegate = new DragBeginNativeDelegate (DragBegin_cb);
				return DragBegin_cb_delegate;
			}
		}

		static void OverrideDragBegin (GLib.GType gtype)
		{
			OverrideDragBegin (gtype, DragBeginVMCallback);
		}

		static void OverrideDragBegin (GLib.GType gtype, DragBeginNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("drag_begin"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragBeginNativeDelegate (IntPtr inst, double start_x, double start_y);

		static void DragBegin_cb (IntPtr inst, double start_x, double start_y)
		{
			try {
				GestureDrag __obj = GLib.Object.GetObject (inst, false) as GestureDrag;
				__obj.OnDragBegin (start_x, start_y);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.GestureDrag), ConnectionMethod="OverrideDragBegin")]
		protected virtual void OnDragBegin (double start_x, double start_y)
		{
			InternalDragBegin (start_x, start_y);
		}

		private void InternalDragBegin (double start_x, double start_y)
		{
			DragBeginNativeDelegate unmanaged = class_abi.BaseOverride<DragBeginNativeDelegate>(this.LookupGType(), "drag_begin");
			if (unmanaged == null) return;

			unmanaged (this.Handle, start_x, start_y);
		}

		static DragUpdateNativeDelegate DragUpdate_cb_delegate;
		static DragUpdateNativeDelegate DragUpdateVMCallback {
			get {
				if (DragUpdate_cb_delegate == null)
					DragUpdate_cb_delegate = new DragUpdateNativeDelegate (DragUpdate_cb);
				return DragUpdate_cb_delegate;
			}
		}

		static void OverrideDragUpdate (GLib.GType gtype)
		{
			OverrideDragUpdate (gtype, DragUpdateVMCallback);
		}

		static void OverrideDragUpdate (GLib.GType gtype, DragUpdateNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("drag_update"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragUpdateNativeDelegate (IntPtr inst, double offset_x, double offset_y);

		static void DragUpdate_cb (IntPtr inst, double offset_x, double offset_y)
		{
			try {
				GestureDrag __obj = GLib.Object.GetObject (inst, false) as GestureDrag;
				__obj.OnDragUpdate (offset_x, offset_y);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.GestureDrag), ConnectionMethod="OverrideDragUpdate")]
		protected virtual void OnDragUpdate (double offset_x, double offset_y)
		{
			InternalDragUpdate (offset_x, offset_y);
		}

		private void InternalDragUpdate (double offset_x, double offset_y)
		{
			DragUpdateNativeDelegate unmanaged = class_abi.BaseOverride<DragUpdateNativeDelegate>(this.LookupGType(), "drag_update");
			if (unmanaged == null) return;

			unmanaged (this.Handle, offset_x, offset_y);
		}

		static DragEndNativeDelegate DragEnd_cb_delegate;
		static DragEndNativeDelegate DragEndVMCallback {
			get {
				if (DragEnd_cb_delegate == null)
					DragEnd_cb_delegate = new DragEndNativeDelegate (DragEnd_cb);
				return DragEnd_cb_delegate;
			}
		}

		static void OverrideDragEnd (GLib.GType gtype)
		{
			OverrideDragEnd (gtype, DragEndVMCallback);
		}

		static void OverrideDragEnd (GLib.GType gtype, DragEndNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("drag_end"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DragEndNativeDelegate (IntPtr inst, double offset_x, double offset_y);

		static void DragEnd_cb (IntPtr inst, double offset_x, double offset_y)
		{
			try {
				GestureDrag __obj = GLib.Object.GetObject (inst, false) as GestureDrag;
				__obj.OnDragEnd (offset_x, offset_y);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gtk.GestureDrag), ConnectionMethod="OverrideDragEnd")]
		protected virtual void OnDragEnd (double offset_x, double offset_y)
		{
			InternalDragEnd (offset_x, offset_y);
		}

		private void InternalDragEnd (double offset_x, double offset_y)
		{
			DragEndNativeDelegate unmanaged = class_abi.BaseOverride<DragEndNativeDelegate>(this.LookupGType(), "drag_end");
			if (unmanaged == null) return;

			unmanaged (this.Handle, offset_x, offset_y);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool d_gtk_gesture_drag_get_offset(IntPtr raw, out double x, out double y);
		static d_gtk_gesture_drag_get_offset gtk_gesture_drag_get_offset = FuncLoader.LoadFunction<d_gtk_gesture_drag_get_offset>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gtk), "gtk_gesture_drag_get_offset"));

		public bool GetOffset(out double x, out double y) {
			bool raw_ret = gtk_gesture_drag_get_offset(Handle, out x, out y);
			bool ret = raw_ret;
			return ret;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool d_gtk_gesture_drag_get_start_point(IntPtr raw, out double x, out double y);
		static d_gtk_gesture_drag_get_start_point gtk_gesture_drag_get_start_point = FuncLoader.LoadFunction<d_gtk_gesture_drag_get_start_point>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gtk), "gtk_gesture_drag_get_start_point"));

		public bool GetStartPoint(out double x, out double y) {
			bool raw_ret = gtk_gesture_drag_get_start_point(Handle, out x, out y);
			bool ret = raw_ret;
			return ret;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr d_gtk_gesture_drag_get_type();
		static d_gtk_gesture_drag_get_type gtk_gesture_drag_get_type = FuncLoader.LoadFunction<d_gtk_gesture_drag_get_type>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gtk), "gtk_gesture_drag_get_type"));

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gtk_gesture_drag_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

#endregion
	}
}
