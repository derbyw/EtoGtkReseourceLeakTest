// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gdk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Threads {

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate uint d_gdk_threads_add_idle_full(int priority, GLibSharp.GSourceFuncNative function, IntPtr data, GLib.DestroyNotify notify);
		static d_gdk_threads_add_idle_full gdk_threads_add_idle_full = FuncLoader.LoadFunction<d_gdk_threads_add_idle_full>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gdk), "gdk_threads_add_idle_full"));

		public static uint AddIdle(int priority, GLib.GSourceFunc function) {
			GLibSharp.GSourceFuncWrapper function_wrapper = new GLibSharp.GSourceFuncWrapper (function);
			IntPtr data;
			GLib.DestroyNotify notify;
			if (function == null) {
				data = IntPtr.Zero;
				notify = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (function_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			uint raw_ret = gdk_threads_add_idle_full(priority, function_wrapper.NativeDelegate, data, notify);
			uint ret = raw_ret;
			return ret;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate uint d_gdk_threads_add_timeout_full(int priority, uint interval, GLibSharp.GSourceFuncNative function, IntPtr data, GLib.DestroyNotify notify);
		static d_gdk_threads_add_timeout_full gdk_threads_add_timeout_full = FuncLoader.LoadFunction<d_gdk_threads_add_timeout_full>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gdk), "gdk_threads_add_timeout_full"));

		public static uint AddTimeout(int priority, uint interval, GLib.GSourceFunc function) {
			GLibSharp.GSourceFuncWrapper function_wrapper = new GLibSharp.GSourceFuncWrapper (function);
			IntPtr data;
			GLib.DestroyNotify notify;
			if (function == null) {
				data = IntPtr.Zero;
				notify = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (function_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			uint raw_ret = gdk_threads_add_timeout_full(priority, interval, function_wrapper.NativeDelegate, data, notify);
			uint ret = raw_ret;
			return ret;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate uint d_gdk_threads_add_timeout_seconds_full(int priority, uint interval, GLibSharp.GSourceFuncNative function, IntPtr data, GLib.DestroyNotify notify);
		static d_gdk_threads_add_timeout_seconds_full gdk_threads_add_timeout_seconds_full = FuncLoader.LoadFunction<d_gdk_threads_add_timeout_seconds_full>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gdk), "gdk_threads_add_timeout_seconds_full"));

		public static uint AddTimeoutSeconds(int priority, uint interval, GLib.GSourceFunc function) {
			GLibSharp.GSourceFuncWrapper function_wrapper = new GLibSharp.GSourceFuncWrapper (function);
			IntPtr data;
			GLib.DestroyNotify notify;
			if (function == null) {
				data = IntPtr.Zero;
				notify = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (function_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			uint raw_ret = gdk_threads_add_timeout_seconds_full(priority, interval, function_wrapper.NativeDelegate, data, notify);
			uint ret = raw_ret;
			return ret;
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void d_gdk_threads_enter();
		static d_gdk_threads_enter gdk_threads_enter = FuncLoader.LoadFunction<d_gdk_threads_enter>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gdk), "gdk_threads_enter"));

		[Obsolete]
		public static void Enter() {
			gdk_threads_enter();
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void d_gdk_threads_init();
		static d_gdk_threads_init gdk_threads_init = FuncLoader.LoadFunction<d_gdk_threads_init>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gdk), "gdk_threads_init"));

		[Obsolete]
		public static void Init() {
			gdk_threads_init();
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void d_gdk_threads_leave();
		static d_gdk_threads_leave gdk_threads_leave = FuncLoader.LoadFunction<d_gdk_threads_leave>(FuncLoader.GetProcAddress(GLibrary.Load(Library.Gdk), "gdk_threads_leave"));

		[Obsolete]
		public static void Leave() {
			gdk_threads_leave();
		}

#endregion
	}
}
